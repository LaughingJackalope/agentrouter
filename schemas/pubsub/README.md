# Pub/Sub Message Schema and API Mapping Logic

This document outlines the JSON schema for messages published to Google Pub/Sub by the AI Agent Message Routing Component and details the mapping from the incoming API request (`POST /v1/messages`) to this Pub/Sub message format.

## 1. Pub/Sub Message Schema

The formal JSON Schema definition for the Pub/Sub messages can be found in [pubsub_message_schema.json](./pubsub_message_schema.json).

**Key characteristics:**

*   **`data` field:** Contains the Base64 encoded JSON string of the original `payload` from the API request. The Message Router does not inspect or modify the content of this payload beyond encoding it.
*   **`attributes` field:** A map of key-value strings providing metadata for routing, idempotency, and auditing.

## 2. Mapping from Incoming API Request to Pub/Sub Message

The Message Routing Component transforms the incoming API request received at `POST /v1/messages` into the Pub/Sub message format defined by the schema.

### Incoming API Request Payload Structure:

```json
{
  "aiAgentAddress": "string",             // REQUIRED. e.g., "agent-sales@yourorg.com"
  "payload": {},                        // REQUIRED. JSON object for the AI Agent.
  "senderMetadata": {                   // OPTIONAL.
    "serviceName": "string",            // e.g., "CRM_System"
    "correlationId": "string",          // Sender-specific correlation ID.
    "senderProvidedMessageId": "string" // OPTIONAL. Sender's own message ID.
  }
}
```

### Mapping Rules:

1.  **`pubsubMessage.data`**:
    *   Source: `apiRequest.payload`
    *   Transformation: The JSON object from `apiRequest.payload` is first stringified and then Base64 encoded.
    *   Example (Python):
        ```python
        import json
        import base64

        api_request_payload_object = {"agentCommand": "process Order 123", "products": ["item1", "item2"]}

        # Stringify the JSON object
        payload_string = json.dumps(api_request_payload_object)

        # Encode the string to Base64
        payload_base64_bytes = base64.b64encode(payload_string.encode('utf-8'))
        pubsub_data_field = payload_base64_bytes.decode('utf-8')

        # print(f"Base64 Encoded Data: {pubsub_data_field}")
        # Example output: "eyJhZ2VudENvbW1hbmQiOiAicHJvY2VzcyBPcmRlciAxMjMiLCAicHJvZHVjdHMiOiBbIml0ZW0xIiwgIml0ZW0yIl19"
        ```

2.  **`pubsubMessage.attributes.messageId`**:
    *   Source: Generated by the Message Routing Component.
    *   Description: A new UUID (Universally Unique Identifier) is generated for each message. This ID is also returned to the original caller in the `202 Accepted` HTTP response of the `POST /v1/messages` API.
    *   Format: UUID string.
    *   Example (Python):
        ```python
        import uuid

        message_id = str(uuid.uuid4())
        # print(f"Generated Message ID: {message_id}")
        # Example output: "123e4567-e89b-12d3-a456-426614174000"
        ```

3.  **`pubsubMessage.attributes.aiAgentAddress`**:
    *   Source: `apiRequest.aiAgentAddress`
    *   Transformation: Direct mapping.

4.  **`pubsubMessage.attributes.timestampPublished`**:
    *   Source: Generated by the Message Routing Component at the time of publication to Pub/Sub.
    *   Description: Current UTC timestamp in ISO 8601 format.
    *   Example (Python):
        ```python
        from datetime import datetime, timezone

        timestamp_published = datetime.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z')
        # print(f"Timestamp Published: {timestamp_published}")
        # Example output: "2023-10-27T10:30:00.123Z"
        ```

5.  **`pubsubMessage.attributes.senderId`** (Optional):
    *   Source: `apiRequest.senderMetadata.serviceName`
    *   Transformation: Direct mapping, if `apiRequest.senderMetadata` and `serviceName` are present.

6.  **`pubsubMessage.attributes.correlationId`** (Optional):
    *   Source: `apiRequest.senderMetadata.correlationId`
    *   Transformation: Direct mapping, if `apiRequest.senderMetadata` and `correlationId` are present.

7.  **`pubsubMessage.attributes.senderProvidedMessageId`** (Optional):
    *   Source: `apiRequest.senderMetadata.senderProvidedMessageId`
    *   Transformation: Direct mapping, if `apiRequest.senderMetadata` and `senderProvidedMessageId` are present.

8.  **`pubsubMessage.attributes.contentType`** (Optional, but defaults for MVP):
    *   Source: Inferred by the Message Router.
    *   Value (for Core Routing MVP): `"application/json"`
    *   Description: As per current requirements, the `apiRequest.payload` is assumed to be a JSON object, so this attribute is set to `"application/json"`.

### Complete Transformation Example (Conceptual Python Pseudo-code):

```python
import json
import base64
import uuid
from datetime import datetime, timezone

def transform_api_request_to_pubsub_message(api_request: dict) -> dict:
    # 1. Prepare 'data' field
    payload_string = json.dumps(api_request.get("payload", {}))
    payload_base64_bytes = base64.b64encode(payload_string.encode('utf-8'))
    pubsub_data = payload_base64_bytes.decode('utf-8')

    # 2. Prepare 'attributes'
    pubsub_attributes = {}

    # messageId (generated)
    pubsub_attributes["messageId"] = str(uuid.uuid4())

    # aiAgentAddress (from request)
    pubsub_attributes["aiAgentAddress"] = api_request.get("aiAgentAddress")

    # timestampPublished (generated)
    pubsub_attributes["timestampPublished"] = datetime.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z')

    # contentType (fixed for MVP)
    pubsub_attributes["contentType"] = "application/json"

    # Optional attributes from senderMetadata
    sender_metadata = api_request.get("senderMetadata", {})
    if sender_metadata:
        if "serviceName" in sender_metadata:
            pubsub_attributes["senderId"] = sender_metadata["serviceName"]
        if "correlationId" in sender_metadata:
            pubsub_attributes["correlationId"] = sender_metadata["correlationId"]
        if "senderProvidedMessageId" in sender_metadata:
            pubsub_attributes["senderProvidedMessageId"] = sender_metadata["senderProvidedMessageId"]

    # Construct the full Pub/Sub message
    pubsub_message = {
        "data": pubsub_data,
        "attributes": pubsub_attributes
    }

    # The messageId generated here would also be returned in the API response to the original sender
    # e.g., return pubsub_message, pubsub_attributes["messageId"]

    return pubsub_message

# Example Usage:
# incoming_api_request = {
#   "aiAgentAddress": "agent-support@example.com",
#   "payload": {"query": "How to reset password?", "userId": "user123"},
#   "senderMetadata": {
#     "serviceName": "WebAppFrontend",
#     "correlationId": "frontend-req-98765",
#     "senderProvidedMessageId": "web-session-abc-123"
#   }
# }
#
# pubsub_message_to_publish = transform_api_request_to_pubsub_message(incoming_api_request)
# print(json.dumps(pubsub_message_to_publish, indent=2))
```

This mapping ensures that all required metadata is available for the AI Agent Consumer Components, supporting idempotency (via `messageId`), routing (via `aiAgentAddress`), and auditability.
```
